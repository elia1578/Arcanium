-- Free

if getgenv().Rayfield then getgenv().Rayfield:Destroy() end
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()

if game.PlaceId == 10595058975 then
	-- Anti Afk
	local VirtualUser = game:GetService('VirtualUser')
	game:GetService('Players').LocalPlayer.Idled:Connect(function()
		VirtualUser:CaptureController()
		VirtualUser:ClickButton2(Vector2.new())
	end)

	-- Adonis Raper

	if not _G.ADONIS_HOOKED then
		_G.ADONIS_HOOKED = true

		local getinfo = getinfo or debug.getinfo
		local DEBUG = false
		local Hooked = {}

		local Detected, Kill

		setthreadidentity(2)

		for i, v in getgc(true) do
			if typeof(v) == "table" then
					local DetectFunc = rawget(v, "Detected")
				local KillFunc = rawget(v, "Kill")
				
				if typeof(DetectFunc) == "function" and not Detected then
					Detected = DetectFunc
					local Old; Old = hookfunction(Detected, function(Action, Info, NoCrash)
						if Action ~= "_" and DEBUG then
							warn(`Adonis AntiCheat flagged\nMethod: {Action}\nInfo: {Info}`)
						end
						return true
					end)
					table.insert(Hooked, Detected)
				end

				if rawget(v, "Variables") and rawget(v, "Process") and typeof(KillFunc) == "function" and not Kill then
					Kill = KillFunc
					local Old; Old = hookfunction(Kill, function(Info)
						if DEBUG then
							warn(`Adonis AntiCheat tried to kill (fallback): {Info}`)
						end
					end)
					table.insert(Hooked, Kill)
				end
			end
		end

		local Old; Old = hookfunction(getrenv().debug.info, newcclosure(function(...)
			local LevelOrFunc, Info = ...
			if Detected and LevelOrFunc == Detected then
				if DEBUG then warn(`zins | adonis bypassed`) end
				return coroutine.yield(coroutine.running())
				end
			return Old(...)
		end))
		setthreadidentity(7)
	end

	wait(2)

    -- Rayfield Window
    local Window = Rayfield:CreateWindow({
        Name = "Arcanium - Free",
        LoadingTitle = "Welcome to Arcanium",
        LoadingSubtitle = "by Yours Truly",
        ShowText = "Arcanium",
        Theme = "Default",
        ToggleUIKeybind = "K",
        DisableRayfieldPrompts = true,
        DisableBuildWarnings = true,
        ConfigurationSaving = {
            Enabled = true,
            FileName = "Arcanium"
        },

		Discord = {
			Enabled = true, -- Prompt the user to join your Discord server if their executor supports it
			Invite = "q3kQ3eESUZ", -- The Discord invite code, do not include discord.gg/. E.g. discord.gg/ ABCD would be ABCD
			RememberJoins = true -- Set this to false to make them join the discord every time they load it up
		},

		KeySystem = false, -- Set this to true to use our key system
    })

    local QOLTab = Window:CreateTab("Quality Of Life", "crown")
    QOLTab:CreateSection("QOL Main")
    QOLTab:CreateLabel("Use these to feel reeeeeal good")

    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local RunService = game:GetService("RunService")    
    local Players = game:GetService("Players")
    local player = Players.LocalPlayer

    -- =========================================================
    -- GLOBALS & DEFAULTS
    -- =========================================================
    _G.AD_ON = _G.AD_ON or false
    _G.AD_METHOD = _G.AD_METHOD or "Legit"
    _G.AQTE_ON = _G.AQTE_ON or false
    _G.AQTE_METHOD = _G.AQTE_METHOD or "Legit"
    _G.INSTANT_END = _G.INSTANT_END or false  -- Option to instantly end fight

    -- =========================================================
    -- SINGLE-INSTANCE GUARD
    -- =========================================================
    _G.__AD_DATA = _G.__AD_DATA or {
        ad_runId = 0,
        qte_runId = 0,
        ad_conn = nil,
        qte_conn = nil,
        activeQTEs = {}
    }
    local State = _G.__AD_DATA

    -- Initialize if they don't exist (for backward compatibility)
    State.ad_runId = State.ad_runId or 0
    State.qte_runId = State.qte_runId or 0
    State.activeQTEs = State.activeQTEs or {}

    local function stopADLogic()
        State.ad_runId = (State.ad_runId or 0) + 1
        if State.ad_conn then 
            State.ad_conn:Disconnect() 
            State.ad_conn = nil
        end
    end

    local function stopQTELogic()
        State.qte_runId = (State.qte_runId or 0) + 1
        if State.qte_conn then 
            State.qte_conn:Disconnect() 
            State.qte_conn = nil
        end
        State.activeQTEs = {}
    end

    -- =========================================================
    -- CORE REMOTE MANAGEMENT
    -- =========================================================
    local function getRemote()
        return ReplicatedStorage:FindFirstChild("Remotes") 
            and ReplicatedStorage.Remotes:FindFirstChild("Information")
            and ReplicatedStorage.Remotes.Information:FindFirstChild("RemoteFunction")
    end

    -- Unified remote caller with proper format handling
    local function callRemote(...)
        local remote = getRemote()
        if not remote then 
            print("[Remote] No remote found")
            return nil 
        end
        
        local args = {...}
        
        if remote:IsA("RemoteEvent") then
            return remote:FireServer(unpack(args))
        elseif remote:IsA("RemoteFunction") then
            return remote:InvokeServer(unpack(args))
        end
    end

    -- Special function to send dodge success with correct format
    local function sendDodgeSuccess()
        -- Format: { true, true, "DodgeMinigame" }
        local args = {
            [1] = {
                [1] = true,
                [2] = true
            },
            [2] = "DodgeMinigame"
        }
        callRemote(unpack(args))
        print("[Dodge] Success signal sent")
    end

    local Sigma = false

    -- Function to instantly end fight
    local function sendFightEnd()
        -- First, temporarily disable the hook
        if remoteHook then
            remoteHook.disable()
        end
        
        -- Send the alternative format that you want
        local args = {
            [1] = false,
            [2] = "DodgeMinigame"
        }
        
        callRemote(unpack(args))
        print("[Fight] Manually ended with alternative format")
        
        -- Re-enable the hook after a short delay
        wait(0.5)
        if remoteHook then
            remoteHook.enable()
        end
    end

    -- Function to send QTE success
    local function sendQTESuccess(qteName)
        -- Format: { true, "QTEName" }
        local args = {
            [1] = true,
            [2] = qteName
        }
        callRemote(unpack(args))
        print("[QTE] Success signal sent for:", qteName)
    end

    -- =========================================================
    -- REMOTE INTERCEPTION SYSTEM - FIXED
    -- =========================================================
    local function installRemoteHook()
        local remote = getRemote()
        if not remote then return nil end
        
        local originalNamecall
        local hookActive = true  -- Always active to intercept false signals
        
        -- Hook to intercept and convert false remotes to true
        originalNamecall = hookmetamethod(game, "__namecall", function(self, ...)
            local method = getnamecallmethod()
            local args = {...}
            
            if self == remote and (method == "FireServer" or method == "InvokeServer") then
                if hookActive then
                    -- Check for failure signals and convert to success
                    if #args >= 2 then
                        local firstArg = args[1]
                        local secondArg = args[2]
                        
                        -- FORMAT 1: {false, "QTEName"} -> convert to { true, "QTEName" }
                        if firstArg == false and type(secondArg) == "string" and secondArg:find("QTE") then
                            local qteName = secondArg
                            print("[Hook] Converting QTE failure to success for:", qteName)
                            
                            -- Send success signal instead: { true, qteName }
                            local successArgs = {
                                [1] = true,
                                [2] = qteName
                            }
                            
                            if remote:IsA("RemoteEvent") then
                                return remote.FireServer(remote, unpack(successArgs))
                            elseif remote:IsA("RemoteFunction") then
                                return remote.InvokeServer(remote, unpack(successArgs))
                            end
                            return nil
                        end
                        
                        -- FORMAT 2: {false, "DodgeMinigame"} -> ALLOW THIS TO PASS THROUGH (manual end fight)
                        -- We don't convert this, we allow it as-is
                        if firstArg == false and secondArg == "DodgeMinigame" then
                            print("[Hook] Allowing manual fight end signal to pass through")
                            return originalNamecall(self, ...)
                        end
                        
                        -- FORMAT 3: {table format} where first element is false
                        if type(firstArg) == "table" then
                            local innerFirst = firstArg[1]
                            local innerSecond = firstArg[2]
                            
                            -- { {false, false}, "DodgeMinigame" } -> convert to { {true, true}, "DodgeMinigame" }
                            if innerFirst == false and innerSecond == false and secondArg == "DodgeMinigame" then
                                print("[Hook] Converting table format dodge failure to success...")
                                
                                -- Send success signal: { {true, true}, "DodgeMinigame" }
                                local successArgs = {
                                    [1] = {
                                        [1] = true,
                                        [2] = true
                                    },
                                    [2] = "DodgeMinigame"
                                }
                                
                                if remote:IsA("RemoteEvent") then
                                    return remote.FireServer(remote, unpack(successArgs))
                                elseif remote:IsA("RemoteFunction") then
                                    return remote.InvokeServer(remote, unpack(successArgs))
                                end
                                return nil
                            end
                        end
                    end
                end
            end
            
            return originalNamecall(self, ...)
        end)
        
        return {
            enable = function()
                hookActive = true
                print("[Hook] Enabled - converting false signals to true")
            end,
            disable = function()
                hookActive = false
                print("[Hook] Disabled - not converting signals")
            end,
            destroy = function()
                if originalNamecall then
                    hookmetamethod(game, "__namecall", originalNamecall)
                    print("[Hook] Destroyed")
                end
            end
        }
    end

    -- Initialize hook
    local remoteHook = installRemoteHook()

    -- =========================================================
    -- UI MANAGEMENT
    -- =========================================================
    local function getCombatUI()
        local playerGui = player:FindFirstChild("PlayerGui")
        return playerGui and playerGui:FindFirstChild("Combat")
    end

    local function hideCombatUI()
        local playerGui = game:GetService("Players").LocalPlayer:FindFirstChild("PlayerGui")
        if not playerGui then return end
        
        local combat = playerGui:FindFirstChild("Combat")
        if not combat then return end
        
        for _, child in ipairs(combat:GetChildren()) do
            if child:IsA("GuiObject") then
                child.Visible = false
            end
        end
    end

    local function isIndicatorInZone(zoneName)
        local combat = getCombatUI()
        local block = combat and combat:FindFirstChild("Block")
        local inset = block and block:FindFirstChild("Inset")
        if not (inset and block and block.Visible) then return false end

        local indicator = inset:FindFirstChild("Indicator")
        local target = inset:FindFirstChild(zoneName)
        if not (indicator and target) then return false end

        local iX = indicator.AbsolutePosition.X + indicator.AbsoluteSize.X / 2
        local tX, tW = target.AbsolutePosition.X, target.AbsoluteSize.X
        
        return iX >= tX and iX <= (tX + tW)
    end

    -- =========================================================
    -- DODGE SYSTEM
    -- =========================================================
    QOLTab:CreateSection("Auto Dodge")

    local ADMethodDropdown = QOLTab:CreateDropdown({
        Name = "Dodge Method",
        Options = {"Instant", "Indicator"},
        CurrentOption = {_G.AD_METHOD == "Legit" and "Indicator" or _G.AD_METHOD},
        MultipleOptions = false,
        Callback = function(opt)
            _G.AD_METHOD = opt[1] == "Indicator" and "Legit" or opt[1]
            stopADLogic()
            -- Don't stop QTE logic when changing Dodge method
        end
    })

    local ADToggle = QOLTab:CreateToggle({
        Name = "Auto Dodge",
        CurrentValue = _G.AD_ON,
        Flag = "AD",
        Callback = function(val)
            _G.AD_ON = val
            stopADLogic()  -- Only stop AD logic
            
            if not val then return end
            
            local myId = (State.ad_runId or 0)
            State.ad_conn = RunService.Heartbeat:Connect(function()
                if (State.ad_runId or 0) ~= myId or not _G.AD_ON then 
                    stopADLogic()
                    return 
                end

                local combat = getCombatUI()
                local block = combat and combat:FindFirstChild("Block")
                if not block then return end
                
                local inset = block:FindFirstChild("Inset")
                
                -- Look for dodge minigame
                if block.Visible then
                    local hasDodge = inset and inset:FindFirstChild("Dodge")
                    local hasBlock = inset and inset:FindFirstChild("Block")
                    
                    if hasDodge or hasBlock then
                        local targetZone = hasDodge and "Dodge" or "Block"
                        
                        if _G.AD_METHOD == "Instant" then
                            -- Send dodge success signal
                            wait(0.5)
                            sendDodgeSuccess()
                            hideCombatUI()
                        elseif _G.AD_METHOD == "Legit" or _G.AD_METHOD == "Indicator" then
                            -- Wait for indicator to be in zone
                            if isIndicatorInZone(targetZone) then
                                local go = combat:FindFirstChild("Go")
                                if go and go.Visible then
                                    sendDodgeSuccess()
                                    hideCombatUI()
                                end
                            end
                        end
                    end
                end
            end)
        end
    })

    -- =========================================================
    -- QTE SYSTEM
    -- =========================================================
    QOLTab:CreateSection("Auto QTE")

    local QTEMethodDropdown = QOLTab:CreateDropdown({
        Name = "QTE Method",
        Options = {"Instant", "Delayed"},
        CurrentOption = {_G.AQTE_METHOD == "Legit" and "Delayed" or _G.AQTE_METHOD},
        MultipleOptions = false,
        Callback = function(opt)
            _G.AQTE_METHOD = opt[1] == "Delayed" and "Legit" or opt[1]
            stopQTELogic()
            -- Don't stop AD logic when changing QTE method
        end
    })

    local AQTEToggle = QOLTab:CreateToggle({
        Name = "Auto QTE",
        CurrentValue = _G.AQTE_ON,
        Flag = "AQTE",
        Callback = function(val)
            _G.AQTE_ON = val
            stopQTELogic()  -- Only stop QTE logic
            
            if not val then return end
            
            local qteNames = {
                "DaggerQTE", "FistQTE", "MagicQTE", 
                "SpearQTE", "SwordQTE", "ThorianQTE"
            }
            
            local myId = (State.qte_runId or 0)
            State.qte_conn = RunService.Heartbeat:Connect(function()
                if (State.qte_runId or 0) ~= myId or not _G.AQTE_ON then 
                    stopQTELogic()
                    return 
                end
                
                local combat = getCombatUI()
                if not combat then return end
                
                for _, qteName in ipairs(qteNames) do
                    local qteUI = combat:FindFirstChild(qteName)
                    if qteUI and qteUI.Visible and not State.activeQTEs[qteName] then
                        State.activeQTEs[qteName] = true
                        
                        task.spawn(function()
                            if _G.AQTE_METHOD == "Instant" then
                                -- Send QTE success immediately
                                hideCombatUI()
                                wait(0.5)
                                sendQTESuccess(qteName)
                            elseif _G.AQTE_METHOD == "Legit" or _G.AQTE_METHOD == "Delayed" then
                                -- Random delay 2-3 seconds for delayed mode
                                local delay = math.random(2000, 3000) / 1000
                                task.wait(delay)
                                
                                if _G.AQTE_ON and qteUI and qteUI.Visible then
                                    sendQTESuccess(qteName)
                                    hideCombatUI()
                                end
                            end
                            
                            task.wait(0.5) -- Cooldown before checking same QTE again
                            State.activeQTEs[qteName] = nil
                        end)
                    end
                end
            end)
        end
    })

    -- =========================================================
    -- LOWER QUALITY BUTTON
    -- =========================================================
    local QOLDivider = QOLTab:CreateDivider()
    QOLTab:CreateButton({
        Name = "Lower Quality",
        Callback = function()
            local Lighting = game:GetService("Lighting")
            local Terrain = workspace:FindFirstChildOfClass("Terrain")
            
            settings().Rendering.QualityLevel = 1
            Lighting.GlobalShadows = false
            Lighting.FogEnd = 9e9
            
            if Terrain then
                Terrain.WaterWaveSize = 0
                Terrain.WaterWaveSpeed = 0
                Terrain.WaterReflectance = 0
                Terrain.WaterTransparency = 0
            end

            task.spawn(function()
                for _, v in ipairs(workspace:GetDescendants()) do
                    if v:IsA("BasePart") then
                        v.Material = Enum.Material.SmoothPlastic
                        v.Reflectance = 0
                    elseif v:IsA("Decal") or v:IsA("Texture") then
                        v.Transparency = 1
                    elseif v:IsA("ParticleEmitter") or v:IsA("Trail") then
                        v.Enabled = false
                    elseif v:IsA("PostEffect") then
                        v.Enabled = false
                    end
                end
                
                Rayfield:Notify({
                    Title = "Quality Lowered",
                    Content = "Textures and effects have been optimized.",
                    Duration = 3
                })
            end)
        end,
    })

    QOLTab:CreateDivider()

	local Players = game:GetService("Players")
	local ReplicatedStorage = game:GetService("ReplicatedStorage")
	local RunService = game:GetService("RunService")

	local player = Players.LocalPlayer
	local Fights = ReplicatedStorage:WaitForChild("Fights")

	-- =========================================================
	-- DEBUG
	-- =========================================================
	local DEBUG = false
	local _last = {}

	local function dbg(key, msg, every)
		if not DEBUG then return end
		every = every or 0.35
		local t = os.clock()
		if not _last[key] or (t - _last[key]) >= every then
			_last[key] = t
			print("[AA]", msg)
		end
	end

	local function dbgOnce(key, msg)
		if not DEBUG then return end
		if _last[key] then return end
		_last[key] = os.clock()
		print("[AA]", msg)
	end

    -- =========================================================
    -- ATTACK SECTION (Optimized)
    -- =========================================================
    local AttackTab = Window:CreateTab("Farming Settings", "settings")
    AttackTab:CreateSection("Attack Main")
    AttackTab:CreateLabel("Sometimes attacks after you get into a fight.")

	local function getAttackSF()
		return player.PlayerGui.Combat.ActionBG.AttacksPage.Attack.ScrollingFrame
	end

	local function getButtonNames()
		local sf = getAttackSF()
		local seen = {}
		local names = {}

		for _, ui in ipairs(sf:GetChildren()) do
			if ui:IsA("TextButton") then
				local t = ui.Name
				if t ~= "" and not seen[t] then
					seen[t] = true
					table.insert(names, t)
				end
			end
		end

		table.sort(names, function(a, b) return a:lower() < b:lower() end)
		table.insert(names, 1, "None")
		return names
	end

	local FirstSkill = AttackTab:CreateDropdown({
		Name = "First Skill",
		Options = {"None"},
		CurrentOption = {"None"},
		MultipleOptions = false,
		Flag = "FS",
		Callback = function(Options)
			_G.AA_FS = (typeof(Options) == "table" and Options[1]) or Options or "None"
			dbg("pick_fs", ("FirstSkill=%s"):format(tostring(_G.AA_FS)), 0.0)
		end,
	})

	local SecondSkill = AttackTab:CreateDropdown({
		Name = "Second Skill",
		Options = {"None"},
		CurrentOption = {"None"},
		MultipleOptions = false,
		Flag = "SS",
		Callback = function(Options)
			_G.AA_SS = (typeof(Options) == "table" and Options[1]) or Options or "None"
			dbg("pick_ss", ("SecondSkill=%s"):format(tostring(_G.AA_SS)), 0.0)
		end,
	})

	local ThirdSkill = AttackTab:CreateDropdown({
		Name = "Third Skill",
		Options = {"None"},
		CurrentOption = {"None"},
		MultipleOptions = false,
		Flag = "TS",
		Callback = function(Options)
			_G.AA_TS = (typeof(Options) == "table" and Options[1]) or Options or "None"
			dbg("pick_ts", ("ThirdSkill=%s"):format(tostring(_G.AA_TS)), 0.0)
		end,
	})

	local function refreshAll()
		local opts = getButtonNames()
		FirstSkill:Refresh(opts)
		SecondSkill:Refresh(opts)
		ThirdSkill:Refresh(opts)
		dbg("refresh", ("Refreshed attacks. options=%d"):format(#opts), 0.25)
	end

	AttackTab:CreateButton({
		Name = "Refresh Attacks",
		Callback = refreshAll,
	})

	task.defer(function()
		pcall(refreshAll)

		local ok, sf = pcall(getAttackSF)
		if ok and sf then
			-- disconnect any existing ones first (prevents buildup if you re-run)
			if _G.AA_SF_ADDED then
				_G.AA_SF_ADDED:Disconnect()
				_G.AA_SF_ADDED = nil
			end
			if _G.AA_SF_REMOVED then
				_G.AA_SF_REMOVED:Disconnect()
				_G.AA_SF_REMOVED = nil
			end

			-- reconnect cleanly
			_G.AA_SF_ADDED = sf.ChildAdded:Connect(function(c)
				if c:IsA("TextButton") then
					dbg("sf_add", ("Attack button added: %s"):format(c.Name), 0.15)
					refreshAll()
				end
			end)

			_G.AA_SF_REMOVED = sf.ChildRemoved:Connect(function(c)
				if c:IsA("TextButton") then
					dbg("sf_rem", ("Attack button removed: %s"):format(c.Name), 0.15)
					refreshAll()
				end
			end)
		else
			dbgOnce("sf_fail", "Could not get Attacks ScrollingFrame yet (Combat UI not ready?)")
		end
	end)


	AttackTab:CreateDivider()

	-- =========================================================
	-- UI action helpers
	-- =========================================================

	local function safeActivate(btn)
		if btn and btn:IsA("GuiButton") then
			dbg("try_" .. btn.Name, ("Try Activate: %s vis=%s act=%s")
				:format(btn:GetFullName(), tostring(btn.Visible), tostring(btn.Active)), 0.75)
		end

		if btn and btn:IsA("GuiButton") and btn.Visible and btn.Active then
			firesignal(btn.MouseButton1Click)
			dbg("did_" .. btn.Name, ("Activated: %s"):format(btn:GetFullName()), 0.75)
			return true
		end

		return false
	end

	local function pickUsableAbility(attacksSF)
		local order = {_G.AA_FS, _G.AA_SS, _G.AA_TS}

		for _, name in ipairs(order) do
			if name and name ~= "None" then
				local btn = attacksSF:FindFirstChild(name)
				if btn and btn:IsA("GuiButton") then
					local cd = btn:FindFirstChild("CD")
					local onCd = (cd and cd:IsA("GuiObject") and cd.Visible) or false
					dbg("ab_check", ("Ability %s onCd=%s"):format(name, tostring(onCd)), 0.5)
					if not onCd then
						return btn
					end
				else
					dbg("ab_missing_" .. tostring(name), ("Ability missing: %s"):format(tostring(name)), 1.0)
				end
			end
		end

		local strike = attacksSF:FindFirstChild("Strike")
		if strike and strike:IsA("GuiButton") then
			local cd = strike:FindFirstChild("CD")
			local onCd = (cd and cd:IsA("GuiObject") and cd.Visible) or false
			dbg("strike_check", ("Strike onCd=%s"):format(tostring(onCd)), 0.5)
			if not onCd then
				return strike
			end
		else
			dbg("strike_missing", "Strike button missing in attacksSF", 1.0)
		end

		return nil
	end

	local function firstEnemyButton(enemiesSF)
		local count = 0
		for _, ui in ipairs(enemiesSF:GetDescendants()) do
			if ui:IsA("TextButton") or ui:IsA("ImageButton") then
				count += 1
				if ui.Visible and ui.Active then
					dbg("enemy_pick", ("Enemy button picked: %s (buttons=%d)")
						:format(ui:GetFullName(), count), 0.25)
					return ui
				end
			end
		end
		dbg("enemy_none", ("No enemy buttons ready (buttons found=%d)"):format(count), 0.35)
		return nil
	end

	-- =========================================================
	-- Auto Attack state machine (anti-spam + guard fallback)
	-- =========================================================

	_G.AA_METHOD = _G.AA_METHOD or "Semi-Legit"

	local AAMethodDropdown = AttackTab:CreateDropdown({
		Name = "Attack Method",
		Options = {"Blatant", "Semi-Legit"},
		CurrentOption = {"Semi-Legit"},
		MultipleOptions = false,
		Callback = function(Options)
			_G.AA_METHOD = Options[1]
		end,
	})

	local AAToggle = AttackTab:CreateToggle({
		Name = "Auto Attack",
		CurrentValue = false,
		Flag = "AA",
		Callback = function(Value)
			_G.AA_ON = Value
			dbg("toggle", ("Toggle AutoAttack=%s"):format(tostring(Value)), 0.0)

			-- OFF: stop
			if not Value then
				if _G.AA_CONN then
					_G.AA_CONN:Disconnect()
					_G.AA_CONN = nil
				end
				dbgOnce("stopped_once", "Auto Attack stopped.")
				return
			end

			-- ON: start (only one connection)
			if _G.AA_CONN then
				dbgOnce("already_running", "Auto Attack already running (connection exists).")
				return
			end

			-- UI refs
			local gui = player:WaitForChild("PlayerGui")
			local combat = gui:WaitForChild("Combat")
			local actionBG = combat:WaitForChild("ActionBG")

			local contextPage = actionBG:WaitForChild("ContextPage")
			local guardButton = contextPage:WaitForChild("GuardButton")

			local attacksSF = actionBG:WaitForChild("AttacksPage"):WaitForChild("Attack"):WaitForChild("ScrollingFrame")
			local enemiesPanel = actionBG.AttacksPage:WaitForChild("Enemies")
			local enemiesSF = enemiesPanel:WaitForChild("ScrollingFrame")

			dbgOnce("boot", "AA loop booted. Turn = ActionBG.Visible true (rising edge).")

			-- ===== helpers =====
			local function pressButton(btn)
				if not btn or not btn:IsA("GuiButton") then return false end
				local ok = pcall(function()
					firesignal(btn.MouseButton1Click)
				end)
				if ok then
					dbg("press_" .. btn.Name, ("Pressed: %s"):format(btn.Name), 0.3)
					return true
				end
				return false
			end

			-- ===== helpers ====

            local function isOnCooldown(btn)
                local cd = btn and btn:FindFirstChild("CD")
                return (cd and cd:IsA("GuiObject") and cd.Visible) or false
            end

			-- ===== DEBUGGED ENERGY & EFFECT HELPERS =====
            
            local function getPlayerModel()
                local living = workspace:FindFirstChild("Living")
                return living and living:FindFirstChild(player.Name)
            end

            local function getPlayerEnergy()
                local charModel = getPlayerModel()
                local status = charModel and charModel:FindFirstChild("Status")
                local energyValue = status and status:FindFirstChild("Energy")
                
                local val = energyValue and energyValue.Value or 0
                dbg("energy_check", ("Current Energy: %d"):format(val), 1.0)
                return val
            end

            -- NEW: Check for Darkcore stacks/value
            local function getDarkcoreValue()
                local charModel = getPlayerModel()
                local effects = charModel and charModel:FindFirstChild("Effects")
                local darkcore = effects and effects:FindFirstChild("Darkcore")
                
                local val = darkcore and darkcore.Value or 0
                dbg("darkcore_check", ("Darkcore Value: %d"):format(val), 1.0)
                return val
            end

            local function getAbilityCost(btn)
                if not btn then return 0 end
                local costContainer = btn:FindFirstChild("Cost")
                local textLabel = costContainer and costContainer:FindFirstChild("TextLabel")
                
                if textLabel and textLabel:IsA("TextLabel") then
                    local cost = tonumber(textLabel.Text) or 0
                    dbg("cost_check_" .. btn.Name, ("%s Cost: %d"):format(btn.Name, cost), 1.0)
                    return cost
                end
                return 0
            end

            local function canUse(btn)
                if not btn or not btn:IsA("GuiButton") then return false end
                
                -- 1. Check Cooldown
                if isOnCooldown(btn) then 
                    return false 
                end
                
                -- 2. Check Energy
                local currentEnergy = getPlayerEnergy()
                local requiredEnergy = getAbilityCost(btn)
                
                if currentEnergy < requiredEnergy then
                    dbg("energy_low", ("Skipping %s: Need %d Energy"):format(btn.Name, requiredEnergy), 0.5)
                    return false 
                end

                -- 3. Special Requirement: Darkcore Eruption
                if btn.Name == "Darkcore Eruption" then
                    local darkcoreVal = getDarkcoreValue()
                    if darkcoreVal < 1 then
                        dbg("darkcore_low", "Skipping Darkcore Eruption: Need at least 1 Darkcore value", 0.5)
                        return false
                    end
                end
                
                -- If all checks pass
                return true
            end

			local function pickBestAbility()
				local order = {_G.AA_FS, _G.AA_SS, _G.AA_TS}
				for _, name in ipairs(order) do
					if name and name ~= "None" then
						local btn = attacksSF:FindFirstChild(name)
						if canUse(btn) then return btn end
					end
				end
				return attacksSF:FindFirstChild("Strike")
			end

			local function firstEnemyButton()
				for _, ui in ipairs(enemiesSF:GetDescendants()) do
					if (ui:IsA("TextButton") or ui:IsA("ImageButton")) and ui.Visible and ui.Active then
						return ui
					end
				end
			end

			-- ===== FSM =====
			local state = "IDLE"
			local stateSince = 0
			local lastTurnVisible = actionBG.Visible
			local isWaitingLegit = false -- NEW: Prevents loop overlap during delay

			-- timing
			local MIN_STEP_GAP = 0.25
			local lastActionAt = 0
			local WAIT_ENEMIES_POPULATE_TIMEOUT = 4.25
			local MAX_STATE_STUCK = 5
			local lastStateChange = os.clock()

			local function go(newState)
				state = newState
				stateSince = os.clock()
				lastStateChange = os.clock()
				dbg("state", ("STATE -> %s"):format(newState), 0.0)
			end

			-- ===== GUARD FAILSAFE =====
			local consecutiveGuards = 0
			local MAX_GUARDS = 3
			local function resetGuardCount() consecutiveGuards = 0 end
			local function guardAndFinish(reason)
				consecutiveGuards += 1
				dbg("guard", ("Guard #%d (%s)"):format(consecutiveGuards, reason or "?"), 0.0)
				pressButton(guardButton)
				go("DONE")
				if consecutiveGuards >= MAX_GUARDS then
					warn("[AA] Guarded " .. consecutiveGuards .. " times! Stopping auto attack.")
					pcall(function() AAToggle:Set(false) end)
					_G.AA_ON = false
					if _G.AA_CONN then _G.AA_CONN:Disconnect() _G.AA_CONN = nil end
				end
			end

			if actionBG.Visible then
				go("PRESS_ABILITY")
			end

			-- ===== HEARTBEAT LOOP =====
			local DONE_RETRY_EVERY = 0.5
			local doneLastTryAt = 0

			_G.AA_CONN = RunService.Heartbeat:Connect(function()
				if not _G.AA_ON or isWaitingLegit then return end

				-- === HEALTH FAILSAFE ===
				local living = workspace:FindFirstChild("Living")
				if living then
					local model = living:FindFirstChild(player.Name)
					if model then
						local hum = model:FindFirstChildOfClass("Humanoid")
						if hum and hum.Health < 15 then
							_G.AA_ON = false
							pcall(function() AAToggle:Set(false) end)
							if _G.AA_CONN then _G.AA_CONN:Disconnect() _G.AA_CONN = nil end
							return
						end
					end
				end

				-- Watchdog
				if os.clock() - lastStateChange > MAX_STATE_STUCK and actionBG.Visible then
					go("PRESS_ABILITY")
				end

				-- Detect NEW TURN
				local nowTurnVisible = actionBG.Visible
				if nowTurnVisible and not lastTurnVisible then
					dbg("turn", "NEW TURN detected", 0.0)
					
					-- LEGIT DELAY INJECTION
					if _G.AA_METHOD == "Semi-Legit" then
						isWaitingLegit = true
						task.spawn(function()
							task.wait(math.random(5, 20) / 10) -- Random 0.5 to 2.0s
							isWaitingLegit = false
							go("PRESS_ABILITY")
						end)
					else
						go("PRESS_ABILITY") -- Blatant (Instant)
					end
					
				elseif (not nowTurnVisible) and lastTurnVisible then
					state = "IDLE"
				end
				lastTurnVisible = nowTurnVisible

				if not nowTurnVisible then return end
				if os.clock() - lastActionAt < MIN_STEP_GAP then return end
				lastActionAt = os.clock()

				-- DONE Retry
				if state == "DONE" then
					local now = os.clock()
					if (now - doneLastTryAt) >= DONE_RETRY_EVERY then
						doneLastTryAt = now
						go("PRESS_ABILITY")
					end
					return
				end

				-- Press ability
				if state == "PRESS_ABILITY" then
					local hasAnyAttackButton = false
					for _, b in ipairs(attacksSF:GetChildren()) do
						if b:IsA("GuiButton") then hasAnyAttackButton = true break end
					end

					if not hasAnyAttackButton then return end

					local btn = pickBestAbility()
					if not btn then
						guardAndFinish("no ability button found")
						return
					end

					local attackBtn = player.PlayerGui.Combat.ActionBG.ContextPage.AttackButton
					pressButton(attackBtn)
					task.delay(0.1, function()
						pressButton(btn)
						go("WAIT_ENEMIES_POPULATE")
					end)
					return
				end

				-- Wait enemies populate
				if state == "WAIT_ENEMIES_POPULATE" then
					local ebtn = firstEnemyButton()
					if ebtn then
						pressButton(ebtn)
						resetGuardCount()
						go("DONE")
						return
					end
					if os.clock() - stateSince > WAIT_ENEMIES_POPULATE_TIMEOUT then
						guardAndFinish("timeout enemies")
					end
				end
			end)
		end,
	})

	task.spawn(function()
		while task.wait(2) do
			if not _G.AA_ON then break end
			if not game:IsLoaded() or not game:GetService("Players").LocalPlayer then break end
			if _G.AA_ON and not _G.AA_CONN then
				warn("[AA] Connection lost â€” restarting auto attack loop.")
				AAToggle.Callback(true)
			end
		end
	end)

    -- =========================================================
    -- PLAYER SECTION (Optimized)
    -- =========================================================
    local PlayerTab = Window:CreateTab("Player", "hand-metal")
    PlayerTab:CreateSection("Player Main")
    PlayerTab:CreateLabel("Tuff player stuff")

    local WS_Enabled = false
    local WS_Value = 16
    local JP_Enabled = false
    local JP_Value = 50
    local NOCLIP_ENABLED = false
    local FLIGHT_ENABLED = false
    local FLIGHT_SPEED = 50

    -- Optimized movement loop
    local movementConn
    local noclipConn
    local flightConn
    local flightBodyVelocity

    local function updateMovementLoop()
        if movementConn then movementConn:Disconnect() end
        
        movementConn = RunService.Heartbeat:Connect(function()
            local char = player.Character
            local hum = char and char:FindFirstChildOfClass("Humanoid")
            if not hum then return end
            
            if WS_Enabled then hum.WalkSpeed = WS_Value end
            if JP_Enabled then 
                hum.JumpPower = JP_Value 
                hum.UseJumpPower = true
            end
        end)
    end

    updateMovementLoop()
    player.CharacterAdded:Connect(function()
        updateMovementLoop()
        -- Reset flight and noclip on new character
        if NOCLIP_ENABLED then
            NOCLIP_ENABLED = false
            pcall(function() NoclipToggle:Set(false) end)
        end
        if FLIGHT_ENABLED then
            FLIGHT_ENABLED = false
            pcall(function() FlightToggle:Set(false) end)
        end
    end)

    PlayerTab:CreateToggle({
        Name = "Hide Names",
        CurrentValue = false,
        Flag = "HN",
        Callback = function(val)
            local HUD = player.PlayerGui:FindFirstChild("HUD")
            if HUD then
                local holders = {"CharacterName", "ServerInfo", "Age/Region"}
                for _, name in ipairs(holders) do
                    local element = HUD:FindFirstChild(name) or 
                                (HUD.Holder and HUD.Holder:FindFirstChild(name))
                    if element then element.Visible = not val end
                end
            end
        end,
    })

    PlayerTab:CreateSection("Movement")

    PlayerTab:CreateToggle({
        Name = "Enable WalkSpeed",
        CurrentValue = WS_Enabled,
        Flag = "WSToggle",
        Callback = function(val)
            WS_Enabled = val
            if not val then
                local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if hum then hum.WalkSpeed = 16 end
            end
        end,
    })

    PlayerTab:CreateSlider({
        Name = "WalkSpeed Value",
        Range = {16, 150},
        Increment = 1,
        Suffix = " Speed",
        CurrentValue = WS_Value,
        Flag = "WSVal",
        Callback = function(val)
            WS_Value = val
        end,
    })

    PlayerTab:CreateToggle({
        Name = "Enable JumpPower",
        CurrentValue = JP_Enabled,
        Flag = "JPToggle",
        Callback = function(val)
            JP_Enabled = val
            if not val then
                local hum = player.Character and player.Character:FindFirstChildOfClass("Humanoid")
                if hum then hum.JumpPower = 50 end
            end
        end,
    })

    PlayerTab:CreateSlider({
        Name = "JumpPower Value",
        Range = {50, 200},
        Increment = 1,
        Suffix = " Power",
        CurrentValue = JP_Value,
        Flag = "JPVal",
        Callback = function(val)
            JP_Value = val
        end,
    })

    -- =========================================================
    -- NOCLIP TOGGLE (Improved with state saving)
    -- =========================================================
    PlayerTab:CreateSection("Collision")

    local originalCollisionStates = {} -- Store original CanCollide states

    local NoclipToggle = PlayerTab:CreateToggle({
        Name = "Noclip",
        CurrentValue = NOCLIP_ENABLED,
        Flag = "Noclip",
        Callback = function(val)
            NOCLIP_ENABLED = val
            
            if noclipConn then
                noclipConn:Disconnect()
                noclipConn = nil
            end
            
            local char = player.Character
            if not char then return end
            
            if not val then
                -- Restore original collision states when turned off
                for part, originalState in pairs(originalCollisionStates) do
                    if part and part.Parent then
                        pcall(function()
                            part.CanCollide = originalState
                        end)
                    end
                end
                originalCollisionStates = {}
                return
            end
            
            -- Store original collision states before changing
            for _, part in ipairs(char:GetDescendants()) do
                if part:IsA("BasePart") then
                    originalCollisionStates[part] = part.CanCollide
                end
            end
            
            -- Noclip loop
            noclipConn = RunService.Stepped:Connect(function()
                if not NOCLIP_ENABLED then 
                    if noclipConn then 
                        noclipConn:Disconnect() 
                        noclipConn = nil 
                    end
                    return 
                end
                
                local char = player.Character
                if char then
                    for _, part in ipairs(char:GetDescendants()) do
                        if part:IsA("BasePart") then
                            -- Store state if we haven't already
                            if originalCollisionStates[part] == nil then
                                originalCollisionStates[part] = part.CanCollide
                            end
                            part.CanCollide = false
                        end
                    end
                end
            end)
        end,
    })

    -- =========================================================
    -- FLIGHT SYSTEM (Improved with Q/E and look direction)
    -- =========================================================
    PlayerTab:CreateSection("Flight")

    local flightSpeedSlider = PlayerTab:CreateSlider({
        Name = "Flight Speed",
        Range = {20, 150},
        Increment = 5,
        Suffix = " Speed",
        CurrentValue = FLIGHT_SPEED,
        Flag = "FlightSpeed",
        Callback = function(val)
            FLIGHT_SPEED = val
            -- Update existing flight velocity if active
            if flightBodyVelocity and flightBodyVelocity.Parent then
                flightBodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000) * FLIGHT_SPEED
            end
        end,
    })

    local FlightToggle = PlayerTab:CreateToggle({
        Name = "Flight",
        CurrentValue = FLIGHT_ENABLED,
        Flag = "Flight",
        Callback = function(val)
            FLIGHT_ENABLED = val
            
            if flightConn then
                flightConn:Disconnect()
                flightConn = nil
            end
            
            if flightBodyVelocity then
                flightBodyVelocity:Destroy()
                flightBodyVelocity = nil
            end
            
            if not val then return end
            
            -- Create flight velocity object
            local char = player.Character
            if not char then return end
            
            local root = char:FindFirstChild("HumanoidRootPart")
            if not root then return end
            
            flightBodyVelocity = Instance.new("BodyVelocity")
            flightBodyVelocity.Name = "FlightVelocity"
            flightBodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000) * FLIGHT_SPEED
            flightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
            flightBodyVelocity.P = 10000
            flightBodyVelocity.Parent = root
            
            -- Flight control loop with look direction movement
            flightConn = RunService.Heartbeat:Connect(function()
                if not FLIGHT_ENABLED or not flightBodyVelocity or not flightBodyVelocity.Parent then 
                    if flightConn then 
                        flightConn:Disconnect() 
                        flightConn = nil 
                    end
                    return 
                end
                
                local char = player.Character
                local root = char and char:FindFirstChild("HumanoidRootPart")
                if not root then return end
                
                -- Get movement direction from camera look direction
                local cam = workspace.CurrentCamera
                local moveDirection = Vector3.new(0, 0, 0)
                
                -- Check input states
                local UIS = game:GetService("UserInputService")
                
                -- Move in the direction the camera is looking
                if UIS:IsKeyDown(Enum.KeyCode.W) then
                    moveDirection = moveDirection + cam.CFrame.LookVector
                end
                if UIS:IsKeyDown(Enum.KeyCode.S) then
                    moveDirection = moveDirection - cam.CFrame.LookVector
                end
                if UIS:IsKeyDown(Enum.KeyCode.A) then
                    moveDirection = moveDirection - cam.CFrame.RightVector
                end
                if UIS:IsKeyDown(Enum.KeyCode.D) then
                    moveDirection = moveDirection + cam.CFrame.RightVector
                end
                
                -- Q for down, E for up (vertical movement)
                if UIS:IsKeyDown(Enum.KeyCode.E) then
                    moveDirection = moveDirection + Vector3.new(0, 1, 0)
                end
                if UIS:IsKeyDown(Enum.KeyCode.Q) then
                    moveDirection = moveDirection - Vector3.new(0, 1, 0)
                end
                
                -- Normalize and apply speed (only if moving)
                if moveDirection.Magnitude > 0 then
                    moveDirection = moveDirection.Unit * FLIGHT_SPEED
                    flightBodyVelocity.Velocity = moveDirection
                else
                    flightBodyVelocity.Velocity = Vector3.new(0, 0, 0)
                end
                
                -- Update max force for speed changes
                flightBodyVelocity.MaxForce = Vector3.new(40000, 40000, 40000) * FLIGHT_SPEED
            end)
        end,
    })

    PlayerTab:CreateButton({
        Name = "Reset Flight (if stuck)",
        Callback = function()
            if flightBodyVelocity then
                flightBodyVelocity:Destroy()
                flightBodyVelocity = nil
            end
            if flightConn then
                flightConn:Disconnect()
                flightConn = nil
            end
            FLIGHT_ENABLED = false
            pcall(function() FlightToggle:Set(false) end)
            Rayfield:Notify({
                Title = "Flight Reset",
                Content = "Flight system has been reset",
                Duration = 3
            })
        end,
    })
else
    Rayfield:Destroy()
end
